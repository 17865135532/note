理解类在JVM中什么时候加载和初始化是Java编程语言的基础概念。感谢Java语言规范，我们拥有一切清晰文档化和解释，但是很多Java程序员仍然不知道什么时候是一个类加载或者一个类被初始化，类加载和初始化好像让人困惑很难以理解对初学者来说，在这篇教程中我们将看看类加载什么时候发生，类和接口是如何被初始化的。我并不会拘泥于类加载器的细节或者说类加载器的工作方式。仅仅使这篇文章专注和简单。  

#####什么时候类被加载
类加载是通过类加载器（classloader）它可以实现成恶汉式加载类尽可能另一个类的音哟哦那个它或者懒加载类直到需要类初始化发生。如果类在真正使用前被加载我相信这跟不同的JVM相关。然而他是受JLS保证的，当有静态初始化的需要的时候。  

####什么时候初始化
在类加载后，初始化类发生意味着初始化所有类的静态成员，一个类被初始化当：  

1. 一个实例创建使用new()关键字或者使用反射class.forName()，它有可能导致 ClassNotFoundException。  
2. 一个静态方法被调用
3. 一个静态域被赋值
4. 一个静态域被使用而且她不是常量
5. 如果类Shi顶级类 而且是断言语句嵌套在里面执行。

反射同样可以导致类的初始化，有时java.lang.reflect包下面的方法导致类的初始化，JLS严格的说，一个类应该不被任何除以上之外的原因初始化。  

####类是如何被初始化的
现在我们知道什么触发类的初始化，他精确文档在java语言规范中。他同样理清不同域的顺序也很重要（静态的和非静态的），块，（静态和非静态的），不同的类（子类和超类）和不同的接口（子接口，实现类和超接口）被初始化。事实上很多核心Java面试题和SCJP问题都是基于这个概念。因为他印象final值如果他的初始化在多个地方，下面是一些规则：  

1. 类从顶至底的顺序初始化，所以字段的声明在顶部的初始化早于底部的字段
2. 超类早于子类和衍生类的初始化
3. 如果类的初始化由于访问静态域而触发，仅仅类有声明静态域被初始化他不会触发超类的初始化或者子类的初始化甚至如果静态域被类型和之类所引用。子接口或者接口类实现
4. 接口初始化不会导致父接口的初始化。
5. 静态域被初始化在静态初始化当非静态域被初始化。这意味这静态域初始化在非静态域之前。  
6. 非静态域通过构造器初始化，子类构造器明确调用父类的构造器在做任何初始化之前。他保证了非静态或实例变量（父类）初始化早于子类

#####初始化例子
这里是一个例子，当类被初始化，你可以看到哪个类被初始化  
//**
代码
*//

#####分析
1. 超类初始化早于子类
2. 静态变量或代码块初始化早于非静态块和域
3. 没使用的类不会被初始化，因为他没有被使用，没有哪个方法在JLS中或者上面例子中会触发类的初始化的

让我们来看一下另一个例子：  
/** 代码块**/
分析：
1. 这里的初始化发生因为静态域被访问它不一个编译时常量。你声明友元编译时常量使用final关键字（注释代码块）超类的初始化不会发生。
2. 仅仅超类被初始化即使静态域被子类引用

还有另外一个例子与接口相关的，他将清晰的解释子接口的初始化不会被父接口的初始化触发。强烈推荐阅读JLS14.4理解类加载和初始化细节。
以上所有就是有关类被初始化和加载的全部内容。我们清楚的看到JLS关于类初始化的指南。我恶魔你同样看到超类与子类被初始化的顺序以及静态和非静态域和块的初始化顺序。  



